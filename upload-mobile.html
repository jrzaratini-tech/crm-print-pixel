<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Scanner de Documento Inteligente</title>

<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.container {
  background: #fff;
  width: 100%;
  max-width: 500px;
  border-radius: 24px;
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
}

.header {
  background: #f8f9fa;
  padding: 24px 20px;
  text-align: center;
  border-bottom: 1px solid #e9ecef;
}

h1 {
  color: #1a1a1a;
  font-size: 24px;
  font-weight: 600;
  margin-bottom: 8px;
}

.subtitle {
  color: #6c757d;
  font-size: 14px;
  line-height: 1.4;
}

.content {
  padding: 24px;
}

.camera-container {
  position: relative;
  width: 100%;
  height: 400px;
  background: #000;
  border-radius: 12px;
  overflow: hidden;
  margin-bottom: 24px;
}

#video {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  border: 2px solid rgba(255, 255, 255, 0.8);
}

#canvas {
  display: none;
}

.preview-container {
  width: 100%;
  max-height: 400px;
  border-radius: 12px;
  overflow: hidden;
  margin-bottom: 24px;
  display: none;
}

#preview {
  width: 100%;
  height: auto;
  display: block;
}

.buttons {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
}

.btn {
  flex: 1;
  padding: 18px;
  border: none;
  border-radius: 14px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.btn:active {
  transform: scale(0.98);
}

.btn-scan {
  background: #10b981;
  color: white;
}

.btn-gallery {
  background: #3b82f6;
  color: white;
}

.btn-retake {
  background: #f59e0b;
  color: white;
}

.btn-send {
  background: #10b981;
  color: white;
}

.btn-cancel {
  background: #6c757d;
  color: white;
}

.controls {
  display: none;
  gap: 12px;
}

.controls.active {
  display: flex;
}

.capture-btn {
  width: 72px;
  height: 72px;
  border-radius: 50%;
  background: white;
  border: 4px solid #f8f9fa;
  position: absolute;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  cursor: pointer;
  box-shadow: 0 4px 20px rgba(0,0,0,0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.capture-btn:active {
  transform: translateX(-50%) scale(0.95);
}

.capture-btn::before {
  content: '';
  width: 56px;
  height: 56px;
  background: white;
  border-radius: 50%;
  border: 2px solid #e9ecef;
}

.loading {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.7);
  z-index: 1000;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 18px;
  flex-direction: column;
  gap: 16px;
}

.loading.active {
  display: flex;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(255,255,255,0.3);
  border-radius: 50%;
  border-top-color: white;
  animation: spin 1s ease-in-out infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.flash {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: white;
  opacity: 0;
  pointer-events: none;
  z-index: 999;
}

@keyframes flash {
  0% { opacity: 0; }
  50% { opacity: 1; }
  100% { opacity: 0; }
}

#fileInput {
  display: none;
}

.status {
  text-align: center;
  padding: 12px;
  font-size: 14px;
  color: #6c757d;
  display: none;
}

.status.active {
  display: block;
}
</style>
</head>

<body>
<div class="container">
  <div class="header">
    <h1>Scanner de Documento</h1>
    <p class="subtitle">Posicione o documento dentro da moldura e toque em capturar</p>
  </div>
  
  <div class="content">
    <div class="camera-container">
      <video id="video" autoplay playsinline></video>
      <div class="overlay"></div>
      <div class="capture-btn" id="captureBtn"></div>
    </div>
    
    <div class="preview-container" id="previewContainer">
      <img id="preview" alt="Pr√©-visualiza√ß√£o do documento escaneado"/>
    </div>
    
    <div class="status" id="status">
      Processando documento...
    </div>
    
    <div class="buttons" id="mainButtons">
      <button class="btn btn-scan" id="scanBtn">
        üìÑ Escanear
      </button>
      <button class="btn btn-gallery" id="galleryBtn">
        üñºÔ∏è Galeria
      </button>
    </div>
    
    <div class="controls" id="controls">
      <button class="btn btn-retake" id="retakeBtn">
        üîÑ Refazer
      </button>
      <button class="btn btn-send" id="sendBtn">
        ‚úÖ Usar Foto
      </button>
    </div>
  </div>
</div>

<div class="loading" id="loading">
  <div class="spinner"></div>
  <div>Processando imagem...</div>
</div>

<div class="flash" id="flash"></div>

<input type="file" id="fileInput" accept="image/*" capture="environment">

<!-- OpenCV.js -->
<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();"></script>

<script>
// Elementos DOM
const video = document.getElementById('video');
const canvas = document.createElement('canvas');
const preview = document.getElementById('preview');
const previewContainer = document.getElementById('previewContainer');
const status = document.getElementById('status');
const loading = document.getElementById('loading');
const flash = document.getElementById('flash');
const controls = document.getElementById('controls');
const mainButtons = document.getElementById('mainButtons');
const captureBtn = document.getElementById('captureBtn');
const scanBtn = document.getElementById('scanBtn');
const galleryBtn = document.getElementById('galleryBtn');
const retakeBtn = document.getElementById('retakeBtn');
const sendBtn = document.getElementById('sendBtn');
const fileInput = document.getElementById('fileInput');

let stream = null;
let cvReady = false;

// Verificar quando OpenCV est√° pronto
function onOpenCvReady() {
  cvReady = true;
  console.log('OpenCV.js carregado e pronto');
}

// Iniciar c√¢mera
async function startCamera() {
  try {
    loading.classList.add('active');
    
    if (stream) {
      stream.getTracks().forEach(track => track.stop());
    }
    
    const constraints = {
      video: {
        facingMode: 'environment',
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      }
    };
    
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    
    // Mostrar bot√£o de captura ap√≥s 1 segundo
    setTimeout(() => {
      captureBtn.style.display = 'flex';
    }, 1000);
    
    // Esconder pr√©-visualiza√ß√£o se estiver vis√≠vel
    previewContainer.style.display = 'none';
    controls.classList.remove('active');
    mainButtons.style.display = 'none';
    
  } catch (error) {
    console.error('Erro ao acessar c√¢mera:', error);
    alert('N√£o foi poss√≠vel acessar a c√¢mera. Verifique as permiss√µes.');
  } finally {
    loading.classList.remove('active');
  }
}

// Capturar imagem
function captureImage() {
  // Efeito de flash
  flash.style.animation = 'flash 0.3s';
  setTimeout(() => {
    flash.style.animation = '';
  }, 300);
  
  // Configurar canvas com dimens√µes do v√≠deo
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  
  // Desenhar imagem do v√≠deo no canvas
  const ctx = canvas.getContext('2d');
  ctx.drawImage(video, 0, 0);
  
  // Parar c√¢mera
  stopCamera();
  
  // Processar documento
  processDocument();
}

// Parar c√¢mera
function stopCamera() {
  if (stream) {
    stream.getTracks().forEach(track => track.stop());
    stream = null;
  }
  captureBtn.style.display = 'none';
}

// Processar documento
function processDocument() {
  if (!cvReady) {
    alert('Aguarde o carregamento do processador de imagens...');
    return;
  }
  
  status.classList.add('active');
  
  // Pequeno delay para garantir que o canvas esteja pronto
  setTimeout(() => {
    try {
      // Ler imagem do canvas
      let src = cv.imread(canvas);
      
      // Redimensionar para processamento mais r√°pido (mantendo propor√ß√£o)
      const maxSize = 800;
      let scale = 1;
      if (src.rows > maxSize || src.cols > maxSize) {
        scale = maxSize / Math.max(src.rows, src.cols);
        let dsize = new cv.Size(Math.round(src.cols * scale), Math.round(src.rows * scale));
        cv.resize(src, src, dsize, 0, 0, cv.INTER_AREA);
      }
      
      // Converter para escala de cinza
      let gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      
      // Aplicar filtro Gaussiano
      cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
      
      // Detectar bordas usando Canny
      let edged = new cv.Mat();
      cv.Canny(gray, edged, 50, 150);
      
      // Dilatar bordas para melhorar detec√ß√£o
      let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
      cv.dilate(edged, edged, kernel);
      
      // Encontrar contornos
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(edged, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
      
      // Encontrar maior contorno quadrangular
      let maxArea = 0;
      let documentContour = null;
      
      for (let i = 0; i < contours.size(); i++) {
        let cnt = contours.get(i);
        let area = cv.contourArea(cnt);
        
        // Ignorar contornos muito pequenos
        if (area < (src.rows * src.cols * 0.05)) continue;
        
        let peri = cv.arcLength(cnt, true);
        let approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
        
        // Verificar se √© quadril√°tero
        if (approx.rows === 4 && area > maxArea) {
          maxArea = area;
          documentContour = approx;
        }
        approx.delete();
      }
      
      // Se encontrou documento, aplicar transforma√ß√£o de perspectiva
      if (documentContour) {
        // Ordenar pontos: [top-left, top-right, bottom-right, bottom-left]
        let points = [];
        for (let i = 0; i < 4; i++) {
          points.push({
            x: documentContour.data32S[i * 2],
            y: documentContour.data32S[i * 2 + 1]
          });
        }
        
        // Ordenar pontos
        points.sort((a, b) => a.y - b.y);
        
        let topPoints = points.slice(0, 2).sort((a, b) => a.x - b.x);
        let bottomPoints = points.slice(2, 4).sort((a, b) => a.x - b.x);
        
        let orderedPoints = [
          topPoints[0], // top-left
          topPoints[1], // top-right
          bottomPoints[1], // bottom-right
          bottomPoints[0]  // bottom-left
        ];
        
        // Calcular dimens√µes
        let widthTop = Math.sqrt(
          Math.pow(orderedPoints[1].x - orderedPoints[0].x, 2) +
          Math.pow(orderedPoints[1].y - orderedPoints[0].y, 2)
        );
        let widthBottom = Math.sqrt(
          Math.pow(orderedPoints[2].x - orderedPoints[3].x, 2) +
          Math.pow(orderedPoints[2].y - orderedPoints[3].y, 2)
        );
        let maxWidth = Math.max(widthTop, widthBottom);
        
        let heightLeft = Math.sqrt(
          Math.pow(orderedPoints[3].x - orderedPoints[0].x, 2) +
          Math.pow(orderedPoints[3].y - orderedPoints[0].y, 2)
        );
        let heightRight = Math.sqrt(
          Math.pow(orderedPoints[2].x - orderedPoints[1].x, 2) +
          Math.pow(orderedPoints[2].y - orderedPoints[1].y, 2)
        );
        let maxHeight = Math.max(heightLeft, heightRight);
        
        // Pontos de origem e destino
        let srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
          orderedPoints[0].x, orderedPoints[0].y,
          orderedPoints[1].x, orderedPoints[1].y,
          orderedPoints[2].x, orderedPoints[2].y,
          orderedPoints[3].x, orderedPoints[3].y
        ]);
        
        let dstPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
          0, 0,
          maxWidth, 0,
          maxWidth, maxHeight,
          0, maxHeight
        ]);
        
        // Aplicar transforma√ß√£o de perspectiva
        let M = cv.getPerspectiveTransform(srcPoints, dstPoints);
        let warped = new cv.Mat();
        cv.warpPerspective(src, warped, M, new cv.Size(maxWidth, maxHeight));
        
        // Limpar mem√≥ria
        srcPoints.delete();
        dstPoints.delete();
        M.delete();
        src.delete();
        src = warped;
      }
      
      // Aplicar filtros para melhorar a legibilidade
      let final = new cv.Mat();
      cv.cvtColor(src, final, cv.COLOR_RGBA2GRAY);
      
      // Aplicar limiariza√ß√£o adaptativa
      cv.adaptiveThreshold(
        final, final, 255,
        cv.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv.THRESH_BINARY, 11, 2
      );
      
      // Mostrar resultado
      cv.imshow(canvas, final);
      preview.src = canvas.toDataURL('image/jpeg', 0.9);
      
      // Mostrar pr√©-visualiza√ß√£o e controles
      previewContainer.style.display = 'block';
      controls.classList.add('active');
      mainButtons.style.display = 'none';
      
      // Limpar mem√≥ria
      gray.delete();
      edged.delete();
      contours.delete();
      hierarchy.delete();
      kernel.delete();
      if (documentContour) documentContour.delete();
      final.delete();
      src.delete();
      
    } catch (error) {
      console.error('Erro no processamento:', error);
      // Fallback: mostrar imagem original com filtro
      const ctx = canvas.getContext('2d');
      let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      applyBWFilter(imageData);
      ctx.putImageData(imageData, 0, 0);
      preview.src = canvas.toDataURL('image/jpeg', 0.9);
      previewContainer.style.display = 'block';
      controls.classList.add('active');
      mainButtons.style.display = 'none';
    } finally {
      status.classList.remove('active');
    }
  }, 100);
}

// Filtro preto e branco (fallback)
function applyBWFilter(imageData) {
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
    const value = avg > 128 ? 255 : 0;
    data[i] = value;     // R
    data[i + 1] = value; // G
    data[i + 2] = value; // B
  }
}

// Event Listeners
scanBtn.addEventListener('click', startCamera);

galleryBtn.addEventListener('click', () => {
  fileInput.click();
});

captureBtn.addEventListener('click', captureImage);

retakeBtn.addEventListener('click', () => {
  previewContainer.style.display = 'none';
  controls.classList.remove('active');
  mainButtons.style.display = 'flex';
  startCamera();
});

sendBtn.addEventListener('click', () => {
  // Aqui voc√™ pode implementar o upload ou processamento adicional
  const imageData = canvas.toDataURL('image/jpeg', 0.9);
  
  // Exemplo: download da imagem
  const link = document.createElement('a');
  link.download = 'documento-escaneado.jpg';
  link.href = imageData;
  link.click();
  
  alert('Documento processado com sucesso! ‚úÖ');
  
  // Resetar interface
  previewContainer.style.display = 'none';
  controls.classList.remove('active');
  mainButtons.style.display = 'flex';
});

fileInput.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = (event) => {
    const img = new Image();
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      processDocument();
    };
    img.src = event.target.result;
  };
  reader.readAsDataURL(file);
});

// Inicializar
window.addEventListener('DOMContentLoaded', () => {
  // Verificar suporte a c√¢mera
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    alert('Seu navegador n√£o suporta acesso √† c√¢mera.');
    scanBtn.disabled = true;
  }
});
</script>
</body>
</html>